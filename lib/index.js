// Generated by CoffeeScript 1.7.1
(function() {
  var EPub, Q, ejs, exec, fs, path, uslug, uuid, _;

  exec = require("child_process").exec;

  path = require("path");

  fs = require("fs");

  Q = require("q");

  _ = require("underscore");

  uslug = require("uslug");

  ejs = require("ejs");

  uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r;
      r = Math.random() * 16 | 0;
      return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
  };

  EPub = (function() {
    function EPub(options) {
      var self;
      this.options = options;
      self = this;
      this.defer = new Q.defer();
      if (!options.title || !options.content) {
        console.log("options not valid");
        return false;
      }
      this.options = _.extend({
        description: options.title,
        publisher: "TXT.SX",
        author: ["anonymous"],
        date: new Date().toISOString(),
        lang: "en"
      }, options);
      if (_.isString(this.options.author)) {
        this.options.author = [this.options.author];
      }
      if (_.isEmpty(this.options.author)) {
        this.operator.author = ["anonymous"];
      }
      if (!this.options.tempDir) {
        this.options.tempDir = path.resolve(__dirname, "../tempDir/");
      }
      this.uuid = path.resolve(this.options.tempDir, uuid());
      this.options.uuid = this.uuid;
      console.log(this.uuid);
      this.options.content = _.map(this.options.content, function(content, index) {
        var reg, titleSlug, _ref;
        titleSlug = uslug(content.title);
        content.filePath = path.resolve(self.uuid, "./OEBPS/" + index + "_" + titleSlug + ".html");
        content.href = "" + index + "_" + titleSlug + ".html";
        content.id = "item_" + index;
        content.author = content.author ? _.isString(content.author) ? [content.author] : !content.author.length ? [] : content.author : [];
        reg = /<body[^>]*>((.|[\n\r])*)<\/body>/;
        content.data = ((_ref = content.data.match(reg)) != null ? _ref[1] : void 0) || content.data;
        return content;
      });
      this.generateTempFile();
      this.defer.promise;
    }

    EPub.prototype.generateTempFile = function() {
      var self, _base;
      self = this;
      if (!fs.existsSync(this.options.tempDir)) {
        fs.mkdirSync(this.options.tempDir);
      }
      fs.mkdirSync(this.uuid);
      fs.mkdirSync(path.resolve(this.uuid, "./OEBPS"));
      (_base = this.options).css || (_base.css = ".epub-author{ color: #555; } .epub-link{ margin-bottom: 30px; } .epub-link a{ color: #666; font-size: 90%; } .toc-author{ font-size: 90%; color: #555; } .toc-link{ color: #999; font-size: 85%; display: block; } hr{ border: 0; border-bottom: 1px solid #dedede; margin: 60px 10%; }");
      fs.writeFileSync(path.resolve(this.uuid, "./OEBPS/style.css"), this.options.css);
      _.each(this.options.content, function(content, index) {
        var data;
        data = "<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en-US\"> <head> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /> <title>" + content.title + "</title> <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" /> </head><body>";
        data += content.title ? "<h1>" + content.title + "</h1>" : "";
        data += content.title && content.author && content.author.length ? "<p class='epub-author'>" + (content.author.join(", ")) + "</p>" : "";
        data += content.title && content.url ? "<p class='epub-link'><a href='" + content.url + "'>" + content.url + "</a></p>" : "";
        data += "" + content.data + "</body></html>";
        return fs.writeFileSync(content.filePath, data);
      });
      fs.writeFileSync(this.uuid + "/mimetype", "application/epub+zip");
      fs.mkdirSync(this.uuid + "/META-INF");
      fs.writeFileSync("" + this.uuid + "/META-INF/container.xml", "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container version=\"1.0\" xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\">\n    <rootfiles>\n        <rootfile full-path=\"OEBPS/content.opf\" media-type=\"application/oebps-package+xml\"/>\n    </rootfiles>\n</container>");
      return ejs.renderFile(path.resolve(__dirname, "./content.ejs"), self.options, function(err, data) {
        if (err) {
          console.error(err);
          self.defer.reject(err);
          return false;
        }
        fs.writeFileSync(path.resolve(self.uuid, "./OEBPS/content.opf"), data);
        return ejs.renderFile(path.resolve(__dirname, "./toc.ejs"), self.options, function(err, data) {
          if (err) {
            console.error(err);
            self.defer.reject(err);
            return false;
          }
          fs.writeFileSync(path.resolve(self.uuid, "./OEBPS/toc.ncx"), data);
          return ejs.renderFile(path.resolve(__dirname, "./content.html"), self.options, function(err, data) {
            if (err) {
              console.error(err);
              self.defer.reject(err);
              return false;
            }
            fs.writeFileSync(path.resolve(self.uuid, "./OEBPS/contents.html"), data);
            return self.genEpub();
          });
        });
      });
    };

    EPub.prototype.genEpub = function() {
      var cleanUp, cwd, filename, initCmd, self, zipCmd;
      self = this;
      console.log(this.uuid);
      filename = "book.epub.zip";
      initCmd = "zip -X -0 " + filename + " mimetype";
      zipCmd = "zip -X -9 -r " + filename + " * -x mimetype " + filename;
      cleanUp = "mv " + filename + " book.epub && rm -f -r META-INF OEBPS mimetype";
      cwd = this.uuid;
      return exec(initCmd, {
        cwd: cwd
      }, function(err, stderr, stdout) {
        if (err) {
          console.error(initCmd, err, stderr, stdout);
          self.defer.reject(err);
          return false;
        }
        if (stderr) {
          console.warn(stderr);
        }
        if (stdout) {
          console.log(stdout);
        }
        return exec(zipCmd, {
          cwd: cwd
        }, function(err, stderr, stdout) {
          if (err) {
            console.error(zipCmd, err, stderr, stdout);
            self.defer.reject(err);
            return false;
          }
          if (stderr) {
            console.warn(stderr);
          }
          if (stdout) {
            console.log(stdout);
          }
          return exec(cleanUp, {
            cwd: cwd
          }, function(err, stderr, stdout) {
            if (err) {
              console.error(cleanUp, err, stderr, stdout);
              self.defer.reject(err);
              return false;
            }
            if (stderr) {
              console.warn(stderr);
            }
            if (stdout) {
              console.log(stdout);
            }
            return self.defer.resolve(this);
          });
        });
      });
    };

    return EPub;

  })();

  module.exports = EPub;

}).call(this);

//# sourceMappingURL=index.map
